---
title: summary for networking 🌐
subtitle: 悄悄地发一下计网总结 🫣
date: 2023-12-27 11:33:00
tags: [dev,专业课,计算机网络, summary]
series: 3
cover: /blog/images/net.png
---

> [!abstract] abstract
>
> 很多程序员的博客里都有一篇计算机网络总结，可以说计算机网络是程序员的白月光（是吗？🤔） 
> 
> 考完之后也悄悄地放一下我的总结，自顶向下的顺序+summary风格，字数很多，可以点上面的目录跳转
>


# 计算机网络 🌐

## 概述

- 资源子网和通信子网
  - 资源子网 个人终端，服务器
  - 通信子网 传输媒体/转发器/集线器/网桥/交换机/路由器等网络互联设备 由 ISP（网络服务提供商）管理

- 交换技术
  - 电路交换
    - FDM（频分复用） TDM（时分复用）
    - 利用率低
    
    分组交换
    - 存储转发 
    - 尽力递交
    - 统计多路复用 分组，按需共享信道
  
- 网络体系结构
  - 应用层 报文
    - HTTP、SMTP、FTP
  - 运输层 报文段
    - TCP UDP
  - 网络层 数据报
    - IP
  - 链路层 帧
  - 物理层
  
- 性能指标

## 应用层 报文 HTTP

- 域名服务 

  -  域名系统 DNS
    - 域名树 层次名字空间
      - 第 0 层 root
      - 第一层 TLD 顶级域名
      - 域 域名树的一颗完整子树
      - 区域 修剪的子树 父区域知道怎么找到子区域，但是子区域不维护父区域的服务器信息
    - 资源记录 RR
      - 类
        - NS 域 管理该域的权威服务器
        - A/AAAA 主机名 IPv4/IPv6 地址
        - CNAME 别名 正式名
        - MX 域 管理该域中用户电子邮箱的服务器
        - PTR IPv4 地址
        - HINFO 主机名
  - 域名解析
    - 递归(recursive)方式：发送请求给下一个服务器，对方给出解析结果 
    - 迭代(iterative)方式：发送请求给下一个服务器，对方给出一个可能知道答案的域名服务器 （开销更少 实践中一般迭代）
  - 域名缓存 Cache
    - 最长后缀匹配
- 传统应用 

  - 邮件
    - MIME
      - 头部 
        - Content-type 内容的类型 type/subtype 缺省为 `text/plain;charset=us-ascii`
        - Content-Transfer-Encoding 编码方式 缺省为 ASCII 
          - quoted-printable
            - 对每个字节
              - 除 = 外的 ascii 码，不变
              - 大于 127 的非 ascii 码，转化为 `=`+16 进制表示（大写字母）==一个字节变 3 个字节==
              - 对 =，转化为 `03D` 本来就是 3D
          - base64
            - 每三字节为一组，按照 4 组六位编码，再转为 ascii 码
              - 怎么转 6 位编码的范围是 0-63 按照 A~Z、a~z、0~9、+ 和/
            - 不满三字节，先划分，不足 6 位的后面补 0，转化结果不足 4 位的补 "="
    - SMTP
      - Client EHLO、MAIL FROM、RCPT TO、DATA、QUIT
        - `CRLF.CRLF` 表示 data 结束
      - Server 状态码+文字说明
        - 250-mail
        - 250 OK
      - 和 DNS 结合
        - 查询 MX 记录，返回有优先级的一系列邮件服务器
          - 若没有 取 A/AAAA 记录
        - 优先级取值越小，越靠近用户邮箱，优先级越高
          - 按优先级取值由小到大，尝试服务器连接（但是不会尝试比当前邮件服务器优先级大的服务器） 
    - POP3
      - 基于文本方式的请求/响应协议，TCP 端口 110
      - 服务方响应：+OK 或-ERR
      - 三个阶段
        - 认证阶段 分别发送 `user <username>` 和 `pass <password>`
        - 事务阶段 
          - `STAT` 返回邮件个数和总长度 
          - `list` 列出邮箱，编号，长度
          - `retr` 读该编号对应的邮箱
          - `dele` 打上删除标签
          - `top` 列出第 n 条消息的前 m 行内容
          - `uidl` 列出所有邮件/某个邮件的 ID
        - 更新阶段 
          - 删除标记过的邮件并退出
  - ftp
    - 控制连接 有一条 tcp 用于维持连接，一条用于传输数据
    - 响应
      - 1xx 正常 是一系列中的一个
      - 2xx 正常
      - 3xx 正常
      - 4xx 暂时错误
      - 5xx 永久错误
    - 两种连接方式 数据 tcp 谁发起
      - active
        - 客户方监听
        - 服务方发起连接 源端口 20
      - passive
        - 客户方发起数据连接 服务方端口可以用 `port` 命令配置
  - web
    - 客户-服务器
  
    - P2P 对等方通信
      - 文件共享 Bittorrent 下载加速（迅雷） 视频会议
      
    - 进程通信接口：socket（IP 地址和端口唯一确定）
- URI
  - ![image-20231220171242907](/blog/images/image-20231220171242907.png)
  
  - 相对 URI 只缺少 scheme，根据后面的内容补充，一般为 http：fudan.edu.cn 或 //fudan.edu.cn
- HTTP

  - 不保存客户信息，无状态协议
- 持续连接和非持续连接

  - 持续连接 所有的请求和响应经过相同的 TCP 连接发送
    - HTTP 1.1 持续连接 $(2\times 1 + N)\times RTT$
    - 流水线 建立连接的 2 个 然后流水线 所以$3RTT$
  - 非持续连接 一个请求/响应对应一个单独的 TCP 连接
    - HTTP 1.0 第一个 HTTP 请求用于建立连接 每个请求 2RTT（一个 tcp+一个 http） N 个对象一共$(N+1)\times 2RTT$
  - HTTP 报文格式
    - 请求报文 ![9a7e577f348a86eb1048c9bd5ea41d6](/blog/images/9a7e577f348a86eb1048c9bd5ea41d6.jpg)

      - 方法：GET/POST/HEAD（调试版本的 GET 返回 http 报文，而不是具体对象)/PUT/DELETE
      - URL：请求对象的相对路径 以/开头 比如 `/somedir/page.html`
      - 版本：http 版本 如 HTTP/1.1
      - 首部字段
        - Connection 是否断开连接 
          - false 非持续连接 每个请求都要断开
          - keep-alive  
            - 1.1 天生就是 7
            - +1.0+如果服务方支持 也可以转成持续连接
        - User-agent 浏览器类型
        - Accept-language 接受的语言
        - Transfer-Encoding 消息体传输采用的编码(包括压缩）方式，比如 gzip, chunked（分块传输）
        - Host 在 1.1 中是必要的 一个 IP 可能对应多个站点 用 Host 指明请求哪一个站点
      - 实体 GET 不需要 POST 会用

    - 响应报文

      - <img src="/blog/images/a54d1912ee27d8a61c7c9354e461ce4.jpg" alt="a54d1912ee27d8a61c7c9354e461ce4" style="zoom:50%;" />
      - 状态码+短语
        - 200 OK
        - 301 Moved Permanently
        - 400 Bad Request
        - 404 Not Found
        - 505 HTTP Version Not Supported
      - 首部字段
        - Date 服务器产生并发送该报文的时间
        - Server 
        - Last-Modified
        - Content-Length 被发送对象的字节数
        - Content-type 
        - Transfer-Encoding
  - Cookie
    - 键值对
    - 请求 Cookie 响应 Set-Cookie
    - 服务器生成和处理 Cookie 浏览器保存 Cookie
  - 缓存/代理
    - 相当于客户端的服务器 服务方的客户端
    - 代理有就返回 没有就请求
  - <img src="/blog/images/image-20231220165016207.png" alt="image-20231220165016207" style="zoom:50%;" />

## 运输层 报文段 TCP

- 运输服务 <span style="color:#FF6666;"> 从下到上第一个端到端 </span>
- UDP
  - 无连接 没有握手
  - 没有差错控制机制 仅仅包含可选的差错检测机制
  - <img src="/blog/images/f3446c3435636df388086d75c64093d.jpg" alt="f3446c3435636df388086d75c64093d" style="zoom:50%;" />


- TCP
  - 可靠数据传输协议的范式
    - 见链路层  [可靠数据传输](#1)
  
  - 面向连接
  
  - 报文段结构
  
    - <img src="/blog/images/24406dcd291a20a07b4f0604219186b.jpg" alt="24406dcd291a20a07b4f0604219186b" style="zoom:50%;" />
  
    - MSS 报文段==数据字段==的最大长度
  
    - 首部一般 20 字节 5 行
  
    - 标志字段 6bit
  
      - ACK
  
      - RST/SYN/FIN 连接建立和拆除
  
      - CWR/ECE 拥塞控制
  
      - PSH 接收方应该立即将数据交给上层
  
      - URG 和 紧急指针 配合 
  
  - 流量控制
  
    - 长肥网络
  
      - BTT*Bandwidth 很大 超过$10^5$ 
    - 接收方缓冲区限制
      - `RecvWindow <= RecvBuffer - (NextByteExpeted - NextByteRead)`
      - 接收窗口+替应用缓存的数据 不能超过整个 buffer
    - 发送方
      - 接收到新的 ACK 更新 `LastByteAcked`
      - 接收到冗余 ACK 多于 3 个进入快速重传
      - 超时 重传第一个未确认的 TCP 段
  - 连接管理
    - 三次握手过程 同步顺序号
  
      - 顺序号 基于时钟的单调递增的 ISN 生成器
      - 具体过程
        - 客户方发送 SYN 段 `SYN=1 ACK=0 SEQ=X`
          - ACK 是希望收到对方的 一开始不知道对方的 所以 `ACK=0` `SYN` 用于同步 只有前两次有
          - 没有 ACK 标志的 SYN 为连接建立请求，之后的 TCP 段 ACK 都会置位
        - 目的主机接收 `ACK=X+1 SYN=1 SEQ=Y`  希望对方发 `X+1`
        - 客户机确认对方的顺序号 `ACK=Y+1 SEQ=X+1`
  
    - 四次挥手过程
  
      - 两方都发送一个 FIN 标志置为 1 的 TCP 段，表示这个方向以后不再有数据要发送
  
      - 另一方在收到 FIN 后，发送 ACK 来确认那个方向的连接被关闭
  
      - 具体过程
  
        - A 方想要关闭连接 发送 `FIN X` 进入 Time-Wait 阶段 只接受数据 不发送数据
          - B 方发送 `ACK X+1` B 方仍可发送数据
  
        - B 方发送 `FIN Y`
          - A 方发送 `ACK Y+1` 连接终止
        - A 方等待 2*MSL（生命周期）才能开启下一个连接 并且==初始顺序号要超过上面使用的最大顺序号==
        - B 方的 `ACK=X+1` 和 `FIN Y` 合并 就变成了 3 次 相当于一种==捎带确认==
  
    - 重传超时计时器
  
      - 估计的 RTT $EstimatedRTT =\alpha\times EstimatedRTT + (1-\alpha)\times SampleRTT$
        - 修正因子$\alpha$ 一般取 7/8 以估算为主
      - 平均偏差 $Deviation =(1-x)\times Deviation + x\times|SampleRTT-EstimatedRTT|$
        - $x = 3/4$ 以修正项为主
        - ==先计算 EstimatedRTT，再算 Deviation==
      - 超时 $Timeout = EstimatedRTT+4Deviation$
      - 重传 TCP 段的超时如何处理
        - 原因
          - 可能测量有误 收到的可能不是重传段的 ACK 是原数据的 ACK
        - 处理
          - 忽略重传段的 RTT
          - 采用指数后退算法 算作原超时的 2 倍
  
    - 保活计时器 KeepAlive（缺省关闭）
  
      - 连接空闲时开启，有数据停止
      - 超时时
        - 发送探测分组 
          - 顺序号 = 收到的最大 ACK 号-1，数据部分长度为 0（缺省实现）；或者 为了与早期的 TCP 实现兼容，发送长度为 1，包含一个字节的垃圾数据（比如 0）
        - 接收者发现顺序号在接收窗口之前会发送 ACK 作为回应 
        - 发送者收到 ACK 时重启 KeepAlive 计时器 
        - 如果没有回应，等待一段时间（75 秒）重发探测分组 
        - 多次探测（9 次）后都没有响应时，连接终止
  
  - 拥塞控制
  
    - 四种模式
      - 慢启动
        - 相对时间 每个 RTT cwnd 以指数倍增加
        - 相对 ACK 每收到一个 ACK cwnd 增加一个 MSS
      - 拥塞避免
        - 相对时间 每个 RTT `cwnd+=1MSS`
        - 相对 ACK 每收到一个 ACK 增加 `(MSS)(MSS/cwnd)`
      - 快速重传 耗时一个 RTT
        - 收到冗余的 `ACK>=3` 实际上收到第 4 个 直接重传 ack 中的顺序号
        - cwnd 没有变化
      - 快速恢复 只占一个$RTT$
        - 对收到的每个冗余的 ACK, cwnd 的值增加一个 MSS
        - 出现新的 ACK 就到拥塞避免
        - 出现超时就慢启动
    - 两种拥塞
      - 超时：重度拥塞
        - `ssthresh = cwnd/2;cwnd=1MSS` 回到慢启动
      - 收到 3 个冗余 ACK 轻度拥塞
        - 先快速重传 然后 `ssthresh = cwnd/2;cwnd=1MSS` 回到慢启动
    - 慢启动，达到阈值，转为拥塞避免
    - 两种拥塞控制方法
      - TCP Tahoe
        - 没有快速恢复
        - ![image-20231223113405846](/blog/images/image-20231223113405846.png)
  
      - TCP Reno
        - ![image-20231223113610193](/blog/images/image-20231223113610193.png)
        - ![image-20231223113652806](/blog/images/image-20231223113652806.png)
  
    - TCP 吞吐率模型的分析方法 
      - AIMD 模型 近似分析
      - ![image-20231223114110606](/blog/images/image-20231223114110606.png)
      - 平均吞吐率$\frac{W/2+W/2+1+...+W}{W/2\times RTT}\approx \frac{3}{4}\times MSS \times \frac{W}{RTT}$
  
    - 在长肥网络下的问题 采用 AIMD 的话，需要很长时间 cwnd 才能达到网络的容量
      - 减少更少
      - 拥塞避免时斜率增大
  

## 网络层 数据报 IP

交换和路由

-  根据何时决定路由分为：
   -  数据报 无连接 
      -  节点根据头部信息和目的地址独立决定路由
   -  虚电路 面向连接
      -  每个节点维护一张虚电路表
      -  动态虚电路 全局虚电路 到来链路的虚电路号和外出电路的虚电路号都是唯一的
-  路由选择
   -  源路由
      -  发送节点决定途径的节点
         -  严格源路由 源路由给出完整的、中途途径的所有路由，必须经过也只经过给出的路由
         -  松散源路由 只给出必须经过的路由 可以经过没有给出的其他路由
   -  逐跳路由
      -  单播 组播
      -  算法
         -  最小花费路由 策略路由（有一些额外要求 比如要越过某些路由器）
         -  静态路由 动态路由
      -  扩散法
      -  逆向学习法

### 数据平面

- IP 协议 IP 提供不可靠无连接

  - IP 分组（数据报）格式

    - <img src="/blog/images/image-20231221195811526.png" alt="image-20231221195811526" style="zoom: 67%;" />

    - 首部长度：用户数据开始的地方 不包含选项时为==20 字节==

      > [!info] info
      >
      > tcp 的头部也是 20 字节
      >
      > IP 数据报的最大长度是 MTU 最大帧长
      >
      > 帧是以太网的单位 因此 MTU 不包含帧头 但是==包含 IP 数据报的头部==
      >
      

  - 分段和重组
    - IP 接收方重组 接收方要可以处理长度至少为 576 字节（*帧大小一般超过 576 字节*）的分段
    - 每个分段包含分段偏移（13bit）：分段携带的数据在原始 IP 分组中携带的数据部分所处位置的 偏移量。单位为==8 个字节== 前面的分段携带==数据长度为 8 的倍数==
    - 该分段的数据长度计算 总长度-头部长度
    - 标识 给分组的编号 现在是 IP 源地址，目的地址，分组标识（即分组编号）决定一个 ip 数据报
      - MF 后面是否还有分段
        - MF = 0 所有分段都来了 可以重组
      - DF 不允许分段 如果必须分段 则丢弃该分组并发送 ICMP 差错报告给发送者
    
  - IP 地址 32bit 整数 4 字节
    - IP => MAC ARP 协议
    - 一共 4 个字节 每个字节转化为十进制数字 中间以 `.` 隔开
    - 一些属于网络部分 一些属于主机
      - ABC 类
        - <img src="/blog/images/image-20231221205659211.png" alt="image-20231221205659211" style="zoom:67%;" />
        - 一般全 0 表示本网络 全 1 表示对所有主机定向广播 所以计算主机数目时都要-2
        - A 1/2 地址空间 一共$2^{24}-2$
        - B 1/4 地址空间 一共$2^{16}-2$
        - C 1/8 地址空间 一共$2^{8}-2$
      - 在 ABC 内部进一步划分子网 因此架构为==network+ subnet+host==
        - 子网掩码
          - `/n` = 前面 n 为都是 1 掩码与 IP 地址按位与 得到子网地址（后面全 1 就是广播地址）
          - 决定网络部分和主机部分的分界线从原来的 IP 地址类确定的界限往右移动，称为子网，往左边移动称为超网
        - CIDR 意思是不管 ABC 了 子网 n 可以是 0-32（/32 表示主机）
          - 转发表中可能会有多个表项匹配，需要采取最长前缀匹配原则：网络掩码最长的匹配
    
  - IP 转发

    - 转发表包含 目的网络/网络掩码/下一跳/网络接口
    - 若$目的 IP 地址\&网络掩码 = 对比的目的网络\&网络掩码$ 则匹配上 按他给的传 注意==子网掩码全 1 的是本机 向上传==
    - 最长前缀匹配 前缀树

  - 内网 IP 地址 只在内网使用

    - ![image-20231221220042521](/blog/images/image-20231221220042521.png)
    - 内网地址 在出口路由器会被过滤 不会出现在 internet 中
    - 经过 NAT 设备映射为公网 IP

-  Internet 网络层
   - ARP IP 映射为 MAC 地址

     - 不知道对应的 MAC 地址 **链路层** 发送 ARP 请求
   
       ![image-20231221220610214](/blog/images/image-20231221220610214.png)
   
     - ARP 缓存了映射对 一定时间（60s、30s）后移走
   
       -  被请求的站点缓存/更新请求者的映射（因为是广播 很多站点收到了）
       -  请求者缓存目的站点的映射
   
     - Spoofing Attack(Man-in-the-Middle)
   
       -  伪造响应
   
   - ICMP 差错报告，网络管理，端系统配置
   
     - 封装在 **IP 分组** 中 协议置为 1
     - 格式
     
       -  <img src="/blog/images/image-20231221222612851.png" alt="image-20231221222612851" style="zoom:67%;" />
       -  消息最少 8 个字节 前两行
       -  <img src="/blog/images/image-20231221223038262.png" alt="image-20231221223038262" style="zoom:67%;" />
     
  - 分类
    
       - 查询消息
            - 直接发到目的端
            - `ping` 就是一种 icmp
       - 差错报告
            - 发回给源端
                 - 数据要包括出错分组的 `IP头部+内部前8个字节（源端口、目的端口、顺序号）`  所以消息大小是 8+20+8 = 36
       - IP 分组递交出错
          -  IP 分组和数据的前 8 个字节作为 icmp 的数据部分
          -  目的地址是源 IP 地址
       - 示例
          - ping
             - 源端发送 <font color="#FF6666"> ICMP Echo 请求 </font>（0）消息到目的地，目的地收到后发送 ICMP Echo 响应（8） 说明可达，并且可以计算 RTT
             - 因为可能丢失，所以一般是连续发送多个请求 通过标识符和顺序号对应请求和响应
             - 途中经过的路由器，通过 IP 分组的选项 RR 完成，途中经过的路由器在转发的时候把 IP 加到 RR 列表中，发送响应是把请求的 RR 字段复制到自己的 RR 中，返回途中经过的路由器也加到 RR 列表中
                - 局限性 IP 分组选项最多只有 40 字节，最多记录 9 个路由器的 IP 地址
          - traceroute 记录两台主机之间经过的路由器
             - 利用==TTL 超时发送的 ICMP 报错==
                - 检测第 i 个经过的路由，发送一个 TTL = i 的 UDP 分组/Echo 给目的主机，因为经过一个路由之后 TTL 会-1，当 TTL 为 0 时，会过期，所以会在第 i 个路由器过期，第 i 个路由器发送一个差错报告给源端
          - path mtu discovery
             - 笨办法，发送试探的 MTU（取本地 MTU 和对方的 MSS 所计算的 MTU 的最小值），并==把 DF 设为 1（不许分段）==，这样超过链路负载时会发送 ICMP 报错，调成较小的再试探
       
   - DHCP 动态主机配置协议 主要是 DHCPDISCOVER/OFFER/REQUEST/ACK 的作用 了解 DHCP Relay
  
       - 分配 IP 地址的协议
            - RARP 以太网广播，返回 IP 地址
            - BOOTP 分配 IP 地址，操作系统映像所在的主机和位置
            - DHCP 分配 IP 地址
       - 三种分配方法
            - 自动方法 根据 MAC 固定分配
            - 动态方法 从地址池中租用一个
            - 手工方法 通过第三方式分配
       - DHCP 工作过程
            - DHCP client 从 DHCP 服务器动态获得 IP 地址（**UDP**）
                 - 服务器维护一个地址池，收到请求后从地址池获得一个可用的地址分配给用户使用一段时间，租期到来前可以续租
            - 分配流程
                 - client：`DHCPDISCOVER => 255.255.255.255` 向本地广播
                 - 服务器：`DHCPOFFER IP [other params] => client` 
                 - client：`DHCPREQUEST => 255.255.255.255`  决定使用该 IP 地址（==也广播==）
                 - 服务器：`DHCPACK` 完成分配过程
            - 续租流程
                 - client：`DHCPREQUEST => 255.255.255.255` 广播一下继续使用该地址
                 - 回复
                      - `DHCPACK` 可以继续使用
                      - `DHCPNACK` 不能用了 需要重新 `DCHPDISCOVER`
                 - 细节 一半时间之后单播，没有收到回应就广播
       - 多个物理网络，路由器不转发本地广播消息 引入==中继代理器，设置服务器地址== relay agent 
            - 服务器根据中继代理器的物理网络位置分配 ip 地址，中继广播给客户端
  
   - NAT 内网到外网 网络地址转换
  
       - NAPT 基于端口的网络地址转换，针对主机的每个会话（TCP 连接，UDP 连接，ICMP 消息）映射
       - 从 NAPT 地址池里选择一个地址+端口
            - 注意的是 NAT 对外网来说是完全取代本地主机的，但是对本地主机来说是透明的
       - 两方都在 NAT 后 NAT 穿越技术，UPnP
  
   - IP 隧道
  
       - 把 IP 网络上的任意两个节点连接起来，在这个连接起来的链路上传出各种类型的分组（IPv4，IPv6，帧）
       - 实现：在路由表中是一个虚拟接口 tun0
       - GRE 封装 任何网络层协议之上传输任何协议的分组提供封装支持 一个 general 的封装方法
            - 封装 IP 分组时 
                 - 版本 0 表示 GRE GRE 头部协议为 0x0800 表示 IP 分组
                 - IP 头部协议字段为 0x47 表示 GRE 分组
            - 有检验和，关键字（识别隧道上的分组流），顺序号（防止失序）

 - IP 组播和 IPv6

   - IP 组播
        - 特殊的 IP 地址
             - D 类 110 开头的地址是组播地址 其中有一些有特殊含义	
                  - `224.0.0.1` 所有主机和所有路由器的地址
                  - `224.0.0.2` 所有组播路由器的地址

        - 组播的实现
             - 应用层播报
                  - 由若干个中继路由器单播

             - IP 组播
                  - 网络层提供支持，组播路由器保证每个链路上最多只会由分组的一份拷贝

        - 任意源组播服务模型与单一源组播服务模型
             - 任意源组播服务模型 ASM
                  - 发送者没有限制，可以不属于组播组
                  - 接收者属于同一个组播组，通过组播地址标识
                  - 组播组任意规模，可以在任意位置动态加入退出
                  - 组播路由器维护组播分发树，组播分组沿着分法树发送

             - 单一源组播服务模型 SSM
                  - 只有一个发送韩国这
                  - 一个组播会话通过 <source, group> 表示
                  - 组播路由维护一个基于源的分发树，更加简单和高效

        - 组成员关系协议 IGMPv2 协议
             - 表示下一个链路上是否有路由组
             - 定义在 ip 上 协议号为 2
             - 流程
                  - 最小的组播路由器充当询问者，定期发消息给所有主机（`224.0.0.1`）
                  - 收到 Query/或新加入时，主机发送 Report 到其所属的组播地址（也就是向该组的所有成员组播自己来了）
                  - 离开组时，发送离组报文到 `244.0.0.2`
                  - 特殊查询 像组播地址发送 询问是否有成员属于该地址（若有的话会有回复的）

             - 软状态机制：定期发送 Query 以刷新状态；超时时移走状态信息
             - 反馈抑制：Query 包含最大响应时间，主机选择 [0, Max Resp. Time] 时刻准备发送 Report



   - IPv6

       - 掌握 IPv6 相比 IPv4 的改进，分组格式之间的变化。具体的 IP 扩展头部不考
       - 掌握 128 比特的地址空间，如何压缩 IPv6 地址。EUI-64 地址不考
       - MTU 最小 1280（IPv4 68）
       - 分组格式变化

           - version 6
           - 不再使用

               - 头部长度 变成了 40 字节的固定长度和不限制长度的扩充选项
               - 取消了和分段有关的字段，只支持源端分段，自己不能想分就分
               - 头部检验和
           - 新增

               - 8bit Next Header 代替协议字段 支持扩展头部
               - 8bit Hop Limit 代替 TTL
               - 16bit Payload Length 除了固定头部的长度（包含扩充部分）
               - 8bit Traffic Class 代替 ToS（type of service 最小时延，最大吞吐量，最高可靠性，最小费用）
               - 20bit Flow Label 表示分组流，用于快速转发
       - IP 地址

           - 128bit 16 个 bit 为一组，一共 8 组 每组用 16 进制书写，组与组之间用冒号分割

               - 每组中前面的 0 可以移走，0123  -> 123 
               - 连续的为全 0 的组可以省略，但仅仅缩写一次 变成一个 0 或者不要

                   -  `8000:0000:0000:0000:0123:4567:89AB:CDEF` => `8000::123:4567:89AB:CDEF`
               - 书写的最后 32bit 是 IPv4 地址
           - 特殊地址

               - 没有广播地址
               - 前面八个 bit 为 1 的是组播地址 `FF00::/8`
       - IPv4 => IPv6 过渡 不考

           - 双协议栈
           - 协议转换
           - 隧道

               - 6to 隧道

### 控制平面

- 路由选择算法
  - 链路选择
  
    - dijkstra 算法
    - 依靠扩散链路状态分组（ISP）生成路由表，然后用 dijkstra 计算最小花费生成树
    - 解决顺序号回绕问题（由于断电等原因 使得新的顺序号小于旧的，新的被覆盖）
      - 可靠的扩散机制 发送 ack 这样就不用重复发送了
      - 每 30 分钟产生一个新的，有变化时产生新的
      - 最大 age 为一个小时，转发和存储时增加，达到最大时清除
      - 到最大顺序号需要回绕时 应该清除原来的 lsa
        - 一个 trick 直接发送顺序号为最大值，age = MaxAge 的 LSA 来清除老的
      - 什么时候接收
        - 顺序号更大 或者 同顺序号更年轻的
  - 距离向量
  
    - 每个节点并不需要知道全局拓扑 只要知道直接连接的节点的链路情况
    - 算法
      - 思想
        - 对边 A ->(val) -> B $V_B = min(V_A+val, V_B)$
      - 流程
        - 从邻居 B 那里收到的路由信息，如果
          - 本地路由表里面没有到该目的地的表项 增加，下一跳为 B
          - 目的地相同，且下一跳为 B，直接更新
          - 目的地相同，下一跳为其他节点，对比花费和 val(A, B)+B 的花费
    - 坏消息收敛很慢/无穷计数
      - 触发更新 
        - 不定时扩散，有变化的时候通知邻居
      - 抑制机制 
        - 不可达就启动抑制定时器 收到更好的就关闭计时器
      - 水平分割
        - 通过一个特定的网络接口 X 发送距离向量时，绝对不要包括通过那个网络接口学习到的 路由信息
      - 带反向抑制的水平分割
        - 给邻居路由器发送路由信息时将那些从该邻居了解到的路由信息的距离设 为无穷大
  - OSPF 开放最短路径优先协议 一种自治系统内部路由协议
  
    - 思想
  
      - 自治系统 由一个或多个独立的管理实体控制的采用相同路由策略的网络和路由器组成
      - 划分成区域，层次路由
      - 路由和路由之间通过组播传递消息
      
    - 各种类型的链路
      - 点到点链路 路由器到路由器的双边
    
      - 末端网络 通过一个路由器连接的网络 可以用路由器到网络的单向边表示
    
      - 广播网络 和广播网络相连的路由器 用双边表示 从路由器到网络有花费 ==从网络到路由器无花费== 使得是否引入网络节点开销一致
    
      - 邻接关系 点到点链路上的邻居关系
    
    - 区域
      - 区域的概念 把很多网络和主机组合在一起 加上连接在其中的路由器 每个区域运行一套自己的区域边界路由器
      
      - 区域和区域之间 运行多个链路状态路由算法的路由器 区域边界路由器 ABR
      
      - 自治系统内的路由
        - 区域内路由 源和目的都在同一区域 只需要区域内部的路由信息来选择路由
        - 区域间路由 源和目的在不同的区域
        
      - 主干区域与本地区域
        - 除了主干区域之外的全部都是本地区域 所有本地区域==之间==的路由必须经过主干区域 ==可推得所有 ABR 一定在主干区域==
          - 两个 ABR 在主干区域不连通会使得区域间路由阻塞，所以可用虚拟链路连接 ABR
            - 虚拟链路的实现 两个 ABR 连接到同一个本地区域，用区域内路由实现
      - 末端区域 
        - 不与外部通信，没有 ASBR 的本地区域
        - 不需要向本地区域扩散第 4、5 类 LSA 
    - 多种路由器
    
        - 内部路由器
        - 区域边界路由器 传第三类汇集 LSA
        - 主干路由器（ABR 都是主干路由器）
        - 自治系统边界路由器（ASBR） 接收第五类自治系统外部 LSA
          - 花费的两种计算 是否算本地的路由花费
      
    - 多种类型 LSA
      1. 路由器 LSA
         -  描述路由器周围情况
         - 内容是周围的网络和花费
      
      2. 网络 LSA
         - 描述网络周围情况
         - 内容是网络直接连接的路由器和从网络出发的花费 回忆：从广播网络到路由的花费为 0
      3. 汇集 LSA
         - ABR 汇总了到本地区域的信息，扩散到主干区域
         - 内容是 该 ABR 到本地区域内所有网络的花费
      4. ASBR 汇集 LSA
         - ABR 构造 到自治系统边界路由的花费
      5. AS 外部 LSA
         - ASBR 构造 自治系统外部路由信息
  - BGP 路由协议
  
    - 传递的是可达性信息，不传绝对花费
    - 如何发现邻居 管理员配置
    -  传递 AS-PATH 路径向量 经过的自治系统列表 可以检测自治系统回路
      - 用 TCP 交换路径向量
      - 比较 RIP UDP 交换距离向量，OSPF IP 可靠扩散
    - E-BGP 和 I-BGP
      - E-BGP：不同自治系统的 BGP 路由器间的 BGP 协议，从相邻的 AS 获得网络可达信息
      - I-BGP：同一个自治系统的 BGP 路由器间的协议
        - 从 E-BGP 了解到的外部自治系统的信息要传递给该自治系统 因为通常都很大 RIP 和 OSPF 做不到 
      - 限制 可以 I 到 E 可以 E 到 I 但是不能 I 到 I 
        - 因为 AS 内部的 I-BGP 邻居之间无法通过路径向量来检测回路 如果允许 会变成全连接
      - BGP 路由决策过程

## 链路层 帧

- 可靠数据传输

  - 确认字段 ACK 顺序号

  - 停等协议

    - 发送方发送当前帧后，等待对方确认
    - 具体算法流程
      - 接收方维护 `frame_expected`
        - 若接受帧的顺序号 ==<\===`frame_expected` `frame_expected++` 发送`ACK frame_expected`
      - 发送方维护 `next_frame_to_send`
        - 收到 ACK 更新 `next_frame_to_send` 发送下一帧
    - 必须包含顺序号
      - 举例 虚假超时（ack） 有一个 ack 在路上 但是发送方已经超时重传，收到的 ack 被认为是重传的 ack，于是发送下一帧，重传帧的 ack 被认为是下一帧的 ack
    - 捎带确认 通信是反向的，ack 由反向传输的帧带过来 反向的帧一般等待 500，200ms
    - ⭐ 性能评价
      - 吞吐率 $\frac{L}{L/B+2R}$
        - <img src="/blog/images/1698757319892-1fd3292b-a006-42ec-92d9-3d9fd240bde1.png" alt="img" style="zoom:50%;" />
      - 算期望 
        - 数据传输失败 $p_1$ ack 传输失败$p_2$
        - 一次失败的概率 $p = 1-(1-p_1)(1-p_2)$
        - 几何分布 期望是$1/p$
        - 一共的次数是成功概率的倒数 即$\frac{1}{1-p}$ 
          - 失败的次数 $\frac{p}{1-p}$ 
        - 为了避免出现误重传 超时间隔应该尽可能大，超过接收到 ACK 的最长时间 $T\geq 2R+\frac{H}{B}$
        - $U =\frac{\frac{D}{B}}{\frac{p}{1-p}(\frac{H+D}{B}+T)+(\frac{H+D}{B}+2R+\frac{H}{B})}=\frac{H+D}{H+D+2RB+H}(1-p_1)(1-p_2)\frac{D}{H+D}$
        - 一帧的误码率 E $1-p_1 =(1-E)^{H+D},1-p_2 =(1+E)^H$
          - 得到$U =\frac{D(1-E)^{2H+D}}{(H+D+BT)}$ 
          - 最佳帧长度 $D_{opt}=\sqrt{\frac{H+BT}{E}}$

  - 管道化 

    - 发送方有一个窗口 缓存  

    - 达到信道的最高利用率：当收到第一个 ACK 时，传下一组

      - $U_{pipeline}=\frac{W*L/B}{2R+L/B}$
      - ![image-20231220220710579](/blog/images/image-20231220220710579.png)
      - 达到 100%的信道利用率  就是上图白的没有
        - $2R =(W-1)L/B => W =\frac{L+2RB}{L}$
        - 所以顺序号至少$\log_2\frac{L+2RB}{L}$

    - 协议

      - 一口气发送窗口内的所有分组

      - 只接受窗口内的分组，否则丢弃

      - GBN

        - 真正的滑动窗口 因为接收是一个一个来的 所以窗口是一个一个向右边滑动的
        - 接收窗口 = 1 累加确认 不会确认失序到达的分组 发送 `ACK N` 代表 N 以前的都已经收到
        - ⭐ 顺序号回绕问题
          - 顺序号 m 发送窗口大小为$2^{m}-1$
            - 例 ack 全部丢了
      
      - 选择重传 允许接收窗口内失序接收
      
        - 滑动到下一个未确认顺序号
        - 两种实现
          - 单独 ACK+超时重传该分组
          - 累加 ACK+NAK 请求重传某一个分组 + 超时重传该分组
            - 分组出错或失序到达时发送 NAK
        - ⭐ 顺序号回绕问题
          - 接收窗口 $\leq$ 发送窗口 一般取等
          - 顺序号 m 发送窗口大小为$2^{m-1}$
            - 例 ack 全部丢了
        
          

- 差错检测

  - 差错控制方式

    - 自动请求重发 ARQ
      - 双向信道，需要发送方缓存
    - 前向纠错 FEC
      - 无需反向信道，纠错码，编码更复杂
    - 混合纠错 HEC
      - 结合版，误码率低时直接纠错，高时重发

  - 常用线性分组码

    - 奇偶校验

      - 垂直 误码率 50% 边发送边编码
      - 水平 长度$\leq p$ 的突发错误 需要记忆 水平是 q 竖直是 p
      - 水平垂直
        - 检测 
          - 3 位及以下的错误（此时至少在某一行/列上一位错） 行和列中的奇数位错误 
          - $\leq p+1$的突发差错
          - 一部分偶数差错（分布导致行和列是奇数个）
        - 纠错 1 位

    - 循环冗余码 ==加法是模 2 加法，除法是模 2 除法==

      - 生成多项式 $G(x)$ r+1 位，最高位为 1

      - $T(x) = x^rK(x)+R(x)$

        $R(x)=x^rK(x)\%G(x)$ 余数

      - 解码 接收的码字除以$G(x)$ 余数为 0 则无错误

        - 理解 $R(x)+R(x)= 0$ 因为 *按位加相当于异或*

    - 海明码 1 位纠错

      - $2^r\geq k+r+1$

        $S_{r-1}...S_0$ 对应无错误 和 $a_{k+r-1}$ 位出错

        取每个等式的第一个位作为冗余位 冗余位取使对应 S 位 0 的值

      - 连续 P 个码字排成一个矩阵(pxn)，每行一个码字，从而可以纠正突发长度$\leq p$的突发错

  - 帧同步

    - 帧结构
      - 8 字节前导+头部+数据+填充+4 字节校验和
        - 前导的长度 8 字节 标志帧的开始 ==不算在帧长里面==
  
        - 最小长度为 64 字节 除去头部（8 目的地址+8 源地址+2 类型）和尾部 4 字节校验和 一共 18 字节 填充字节为 0-46 字节
  
        - 帧的有用部分为 ==总长度-18==字节
      - 帧同步
        - 面向字符的同步协议 异步协议 PPP
          - DLE：`0x7d` 对于需要转义的特殊字符，在前面添加 `0x7d` 并且本身半加 `0x20`
          - DLE 自己 变成 `0x7d5d`
        - 面向比特的同步规程 比特填充
          - 确保数据部分不会出现 5 个 1 连续出现 5 个 1 就插入 0
          - `01111110` 表示帧的开始和结束
  
  - 数据链路层协议
  
- 媒体访问控制（多路访问链路和协议）

  - 广播信道中的多路访问协议，减少碰撞发生的次数

  - 信道划分协议

    - TDM 时分多路复用 把时间帧分成 N 个时隙（slot） 每个刚好可以传输单个分组 每个发送方轮流
    - FDM 频分多路复用 将信道划分成不同频段 
    - CDMA 码分多址 对每个节点分配一种或不同的编码 使得不同的节点可以同时传输，且不会相互干扰

  - 随机接入协议

    - 一个传输节点以信道的全部速率进行发送或更换 有碰撞时，涉及碰撞的每个节点反复地重发它的分组（等待一个随机时延），直到无碰撞地通过

    - 时隙 ALOHA/分槽 ALOHA

      - 每个时隙可以恰好通过一个帧，每个节点在时隙的开始发送帧，在时隙结束时，如果没有碰撞，就不做什么，如果检测到碰撞，在下一个时隙，有概率 p 重发该帧
        - 刚好有一个节点传输的时隙是 **成功时隙**
        - 定义 **效率** 长期运行中成功时隙的份额
          - 最大效率 $Np(1-p)^{N-1}$ N 趋于无穷，取 P 最大值 即为 1/e
          - G 归一化的网络负载 平均每帧时传输 G 帧 ==吞吐量 $S = G\times P_{succ}$==

    - ALOHA

      - 非时隙 完全分散  区别是 不在时隙开始时发送，收到分组后立刻发送 发生碰撞后以概率 p 重传，否则等待，等待后概率 p 重传...

      - 效率计算 若在 t 时刻开始传输，则 t-1 到 t+1 这 2t 时间内都不可以有其他分组传输

        - $p(1-p)^{2(N-1)}$ 最大值 1/2e

        - 每帧时发送帧的平均值是 G，任一帧时生成 k 帧的概率服从泊松分布

          $$P_r[k]=\frac{G^ke^{-G}}{k!}$$

          所以传输成功的概率是 $p=p_r[0]^2=e^{-2G}$

          吞吐率 $S=G\times P_{succ}=Ge^{-2G}$

          对 G 求导 得到最大值是 1/2e

          ![c76643db0803486afc65738ae72e119](/blog/images/c76643db0803486afc65738ae72e119.jpg)

          > [!abstract] abstract
          >
          > 可能考：
          >
          > - 频率转概率
          >
          >   10%的时槽是空闲的 <=> 一个时槽是空闲的的概率是 0.1 <=> $e^{-G}=0.1, G=-\ln(0.1)$
          >   
          > - 吞吐率 $S=G\times P_{succ} $ 
          >
          >   $S\geq G$ 轻负载 
          >
          >   $S<G$ 重负载
          >

    - 载波监听多路访问 CSMA

      - 监听信道 有一小段时间信道上没有传输时开始传输
      - 实际上还是会发送碰撞 受信道传输时延的影响 可能此刻信道上有传输 只是还没有传到节点这里来
    
    - 具有碰撞检测的载波侦听多路访问 CSMA/CD
    
      - 检测到碰撞（监听是否有来自其他适配器的信号能量）后放弃传输

        - ==传输时间$\geq$冲突检测时间 = 2$\times$传播时间（即传播时延乘网段数）==
        - 传输时间 = 帧长/传输速率
        - 定义 一个时槽 = 2$\times$传播时间 

      - 二进制指数后退算法

        - 希望碰撞节点数量少时，少等待一点时间，碰撞节点数多时，多等待一段时间
        - 经历 n 次碰撞后，在$\{0,1,2,...,2^{n}-1\}$ 中随机选择一个 K，然后等待 K 倍 512bit 时间（发送 512bit 进入以太网所需时间）
          - n 小于等于 10
          - 大于 10 之后 最大 K 固定为 1023
          - 等于 16 次后 放弃传输，报告错误 
    
      - 效率计算
    
        - 定义为：有大量的活跃节点，且每个节点有大量的帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额
    
        - $d_{prop}$ 信道能量在任意两个适配器之间传输所需的最大时间（传播时延）
    
          $d_{trans}$ 传输一个最大长度的以太网帧的时间
    
          $效率=\frac{1}{1+5d_{prop}/d_{trans}}$
          
          ![image-20231219142436560](/blog/images/image-20231219142436560.png)
          
          ![image-20231219142427317](/blog/images/image-20231219142427317.png)
          
          ![image-20231219142448177](/blog/images/image-20231219142448177.png)
    
  - 轮流协议
  
    - 轮询协议
      - 有主节点轮询每一个节点 告诉每个节点可以发送的最多数量
      - 缺点 轮询时延，主节点坏了全部崩溃
    - 令牌传送协议
      - 有一个令牌按某种特定次序交换 拿到令牌的才能发送，没有需要发送的数据就迅速地传给下一个人
  
- 以太网

  - ![image-20231219143744623](/blog/images/image-20231219143744623.png)

  - 向上层提供无连接方式的不可靠数据传输服务

    ![image-20231219142832108](/blog/images/image-20231219142832108.png)

    ![image-20231219142853672](/blog/images/image-20231219142853672.png)

- MAC 地址

  - 节点通过网卡连接到局域网
  - 且媒体访问控制机制保证一个时间只有一个发送者
  - 每个节点在局域网内有唯一的 MAC 帧的头部给出源 MAC 地址和目的 MAC 地址
    - 为了保证这种随机性 每一块网卡都有唯一的 MAC 地址 用==平坦地址空间==

  - 描述
    - 每个字节 16 进制 用 `-` 或者 `:` 隔开 一共 6 个字节
    - 最低位在前 前两位有特殊含义
      - 第一位 I/G 0 表示单播地址 1 表示组播地址
      - 第二位 U/L 0 表示全局地址 1 表示本地管理地址

    - 💥 表示的时候是从小到大表示，但是一个字节内是从高到低读
      - ![image-20231221204851748](/blog/images/image-20231221204851748.png)

  - 链路处理
    - 单播 
      - 目的==MAC 传给上层
      - 目的$\neq$ MAC 丢弃

    - 广播 发送帧给链路上的所有接收者  FF-FF-FF-FF-FF-FF
      - 直接接收 传给上层

    - 组播 
      - 网卡维护一些感兴趣的组播地址的值或者散列值 匹配时递交上层 否则丢弃

- 网桥

  ![image-20231219155045881](/blog/images/image-20231219155045881.png)

  - 冲突域和广播域
    - 冲突域 同一时间只能由一台设备可以发送信息的范围 第二层设备可以隔离（交换机）
    - 广播域 一个站点发出一个广播信号，所有能接收到这个信号的设备范围 路由器可以隔离广播域 

  - 根据 mac 帧的目的地址，转发帧
    - 到来帧的目的地址所在端口与当前端口一致，过滤

    - 转发表有，转发

    - 转发表没有，扩散

  - 生成树算法
    - 生成树的根桥为 BID（2B 优先级+6B MAC 地址）最小的网桥
      - 网桥到根桥上具有最小花费的路径上第一个跳段使用的端口

    - 选取桥 每个局域网到根桥的路径最短的桥中，BID 最小的
      - 连接到该局域网上的端口为选取端口 其他阻塞

- 虚拟局域网

  - 对LAN做进一步划分，帧只能在有相同VLAN标识的网段间转发
  - 分割方法
    - 基于端口 根据交换机的端口
    - 基于MAC地址 
    - 基于协议 根据网络层的协议

  - 局域网交换机
    - 局域网交换机实际上是一种高性能的多端口网桥

    - 帧转发方式
      - 存储转发 完全接收到帧之后
      - 直通 收到目的地址就开始转发 但是没有差错检验
      - 无残帧 收到前64字节就开始转发 因为错误一般发生在前64个


## 物理层 

- 信道的最大数据速率
  - 那奎斯特定理
    - $C = 2H\log_2L$ 
      - H 有限带宽
      - L 信号可取的离散值 ==一共有多少种取法，和调制有关，星座图上多少个点==
    - 波特率 B 每秒信号状态变化的次数 单位波特 $C = B\log_2L$ 信号状态变化的速率
  - 香农定理
    - $C = H\log_2(1+\frac{S}{N})$
    - 信噪比 SNR $10\log(\frac{S}{N})dB$=
    - 转化 分贝值 x 信噪比 $10^{\frac{x}{10}}$
  - 信道的最大数据速率应该受到这两者的制约，取两者的最小值
  - 扩大频率可以增大信道的速率
- 数据编码
  - 解决问题
    - 时钟恢复：根据跳变来恢复时钟，可能长时间无跳变，接收和发送端之间很难进行比特同步
    - 基线漂移 平均信号是基线 是上下漂移的
  - 编码
    - NRZ(Non-Return-Zero）编码
      - 正电 1 负电 0
    - NRZI(NRZ Inverted on ones)编码 差分编码
      - 相比于前一个电压 有没有跳变来表示 0 和 1
      - 用信号的跳变来表示 1，无跳变表示 0
    - 曼彻斯特编码
      - 时钟和 NRZ 编码异或而成
      - 高电压-> 低电压为 1，低电压-> 高电压为 0
    - 差分曼彻斯特编码
      - 比特时间的开始处的跳变有无来表示 0 或者 1：有跳变表示 0，没有跳变表示 1
      - 缺点 只有 50%编码效率 因为波特率是 2 倍
    - 4B5B
      - 按 4 个 bit 分组 映射到 5 个 bit 然后用非归零反转编码进行编码
        - 映射时使前面不多于 1 个 0 后面不多于两个 0 （16 个组合 有映射表）
        - 编码效率 80%
  - 数字调制
    - 数字信号变模拟信号
    - 调幅 调频 调相
    - 星座图 相位和幅度
      - ![image-20231223163553027](/blog/images/image-20231223163553027.png)
  - 脉码调制 模拟 => 数字
    - 脉码调制 PCM