---
title: Jax 101-6 ğŸ¤
subtitle: Working with Pytrees ğŸŒ²
date: 2024-01-30 23:33:00
tags: [dl,jax]
series: 5
cover: /blog/images/jax.jpg
---

# Working with Pytrees ğŸŒ²

## What is a pytree

æˆ‘ä»¬æ“ä½œçš„å¯¹è±¡é€šå¸¸æ˜¯ç”±æ•°ç»„ç»„æˆçš„å­—å…¸ï¼Œæˆ–è€…lists of lists of dictsï¼Œæˆ–è€…å…¶ä»–åµŒå¥—çš„ç»“æ„ã€‚åœ¨Jaxä¸­ï¼Œè¿™ç§ç»“æ„è¢«ç§°ä¸º*pytrees*

å®˜æ–¹çš„å®šä¹‰æ˜¯[^1]ï¼š

> a pytree is a container of leaf elements and/or more pytrees. Containers include lists, tuples, and dicts. A leaf element is anything thatâ€™s not a pytree, e.g. an array. In other words, a pytree is just a  possibly-nested standard or user-registered Python container. If nested, note that the container types do not need to match. A single â€œleafâ€,  i.e. a non-container object, is also considered a pytree.

épytreeçš„å…ƒç´ éƒ½å¯ä»¥ä½œä¸ºleafï¼Œé™¤äº†listã€tuplesã€dictsçš„å¯è¿­ä»£å®¹å™¨ä¹Ÿå¯ä»¥ä½œä¸ºleafï¼æ¯”å¦‚`np.array`

ä¾‹å¦‚ï¼š

```python
import jax
import jax.numpy as jnp

example_trees = [
    [1, 'a', object()],
    (1, (2, 3), ()),
    [1, {'k1': 2, 'k2': (3, 4)}, 5],
    {'a': 2, 'b': (2, 3)},
    jnp.array([1, 2, 3]),
]

# Let's see how many leaves they have:
for pytree in example_trees:
  leaves = jax.tree_util.tree_leaves(pytree)
  print(f"{repr(pytree):<45} has {len(leaves)} leaves: {leaves}")
```

> [!tip] Tips
>
> `repr()`[^2]
>
> The `repr()` function returns a printable representation of the given object.

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œç”¨`jax.tree_util.tree_leaves`æ¥æ”¶ä»»æ„åµŒå¥—ç»“æ„ï¼Œå¯ä»¥è¿”å›æ‰å¹³åŒ–çš„ä¸‹ä¸€çº§æ•°æ®

### Why pytrees

åœ¨mlä¸­ï¼Œpytreeçš„ç”¨é€”æœ‰ï¼š

- Model parameters
- Dataset entries
- RL agent observations

## `jax.tree_map`

`jax.tree_map`æŠŠpythonçš„`map`æ–¹æ³•æ‹“å±•åˆ°å¯¹æ‰€æœ‰pytreeç»“æ„

> [!Note] `map`[^3]
>
> ```python
> map(function, iterable, ...)
> ```
>
> å¯¹å¯è¿­ä»£å¯¹è±¡ä¸­æ¯ä¸ªå…ƒç´ æ“ä½œï¼Œè¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä¹Ÿå¯ä»¥å¯¹å¤šä¸ªå¯¹è±¡æ“ä½œ
>
> ç¤ºä¾‹ï¼š
>
> ```python
> >>> def square(x) : Â  Â  Â  Â  # è®¡ç®—å¹³æ–¹æ•°
> ... Â  Â  return x ** 2
> ... 
> >>> map(square, [1,2,3,4,5]) Â  Â # è®¡ç®—åˆ—è¡¨å„ä¸ªå…ƒç´ çš„å¹³æ–¹
> <map object at 0x100d3d550> Â  Â  # è¿”å›è¿­ä»£å™¨
> >>> list(map(square, [1,2,3,4,5])) Â  # ä½¿ç”¨ list() è½¬æ¢ä¸ºåˆ—è¡¨
> [1, 4, 9, 16, 25]
> >>> list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) Â  # ä½¿ç”¨ lambda åŒ¿åå‡½æ•°
> [1, 4, 9, 16, 25]
> >>>>>> list(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))
> [3, 7, 11, 15, 19]
> ```

ä¸ä¹‹ç±»ä¼¼ï¼Œ`jax.tree_map`å¯ä»¥æ“ä½œå•ä¸ªå¯¹è±¡ï¼Œä¹Ÿå¯ä»¥æ“ä½œå¤šä¸ª

```python
list_of_lists = [
    [1, 2, 3],
    [1, 2],
    [1, 2, 3, 4]
]

jax.tree_map(lambda x: x*2, list_of_lists)
```

```
[[2, 4, 6], [2, 4], [2, 4, 6, 8]]
```

```python
another_list_of_lists = list_of_lists
jax.tree_map(lambda x, y: x+y, list_of_lists, another_list_of_lists)
```

```
[[2, 4, 6], [2, 4], [2, 4, 6, 8]]
```

## Exampleï¼š ML model parameters

åˆå§‹åŒ–å‚æ•°ï¼š

```python
import numpy as np

def init_mlp_params(layer_widths):
  params = []
  for n_in, n_out in zip(layer_widths[:-1], layer_widths[1:]):
    params.append(
        dict(weights=np.random.normal(size=(n_in, n_out)) * np.sqrt(2/n_in),
             biases=np.ones(shape=(n_out,))
            )
    )
  return params

params = init_mlp_params([1, 128, 128, 1])
```

```
[{'biases': (128,), 'weights': (1, 128)},
 {'biases': (128,), 'weights': (128, 128)},
 {'biases': (1,), 'weights': (128, 1)}]
 
```

> [!tip] `zip`[^4]
>
> ```python
> >>> a = [1,2,3]
> >>> b = [4,5,6]
> >>> c = [4,5,6,7,8]
> >>> zipped = zip(a,b) Â  Â  # è¿”å›ä¸€ä¸ªå¯¹è±¡
> >>> zipped
> <zip object at 0x103abc288>
> >>> list(zipped) Â # list() è½¬æ¢ä¸ºåˆ—è¡¨
> [(1, 4), (2, 5), (3, 6)]
> >>> list(zip(a,c)) Â  Â  Â  Â  Â  Â  Â # å…ƒç´ ä¸ªæ•°ä¸æœ€çŸ­çš„åˆ—è¡¨ä¸€è‡´
> [(1, 4), (2, 5), (3, 6)]
> 
> >>> a1, a2 = zip(*zip(a,b)) Â  Â  Â  Â  Â # ä¸ zip ç›¸åï¼Œzip(*) å¯ç†è§£ä¸ºè§£å‹ï¼Œè¿”å›äºŒç»´çŸ©é˜µå¼
> >>> list(a1)
> [1, 2, 3]
> >>> list(a2)
> [4, 5, 6]
> ```
>
> éƒ½å–ç¬¬iä¸ªï¼Œç»„æˆå…ƒç»„

å¯ä»¥ç”¨`jax.tree_map`æ£€éªŒå½¢çŠ¶

```python
jax.tree_map(lambda x: x.shape, params)
```
```
[{'biases': (128,), 'weights': (1, 128)},
 {'biases': (128,), 'weights': (128, 128)},
 {'biases': (1,), 'weights': (128, 1)}]
```

å¯ä»¥åœ¨æ­¤åŸºç¡€ä¸Šåšä¸€ä¸ªç®€å•çš„è®­ç»ƒï¼š

```python
def forward(params, x):
  *hidden, last = params
  for layer in hidden:
    x = jax.nn.relu(x @ layer['weights'] + layer['biases'])
  return x @ last['weights'] + last['biases']

def loss_fn(params, x, y):
  return jnp.mean((forward(params, x) - y) ** 2)

LEARNING_RATE = 0.0001

@jax.jit
def update(params, x, y):

  grads = jax.grad(loss_fn)(params, x, y)
  # Note that `grads` is a pytree with the same structure as `params`.
  # `jax.grad` is one of the many JAX functions that has
  # built-in support for pytrees.

  # This is handy, because we can apply the SGD update using tree utils:
  return jax.tree_map(
      lambda p, g: p - LEARNING_RATE * g, params, grads
  )
```

æ‹Ÿåˆä¸€ä¸ªäºŒæ¬¡å‡½æ•°

```python
import matplotlib.pyplot as plt

xs = np.random.normal(size=(128, 1))
ys = xs ** 2

for _ in range(1000):
  params = update(params, xs, ys)

plt.scatter(xs, ys)
plt.scatter(xs, forward(params, xs), label='Model prediction')
plt.legend();
```

![ee94d1109f9298be770c02a507b0dcfc28898c5ae97963c1ed13eb0d34bfe49a](/blog/images/ee94d1109f9298be770c02a507b0dcfc28898c5ae97963c1ed13eb0d34bfe49a.webp)

## Key paths

åœ¨ pytree ä¸­ï¼Œæ¯ä¸ªleaféƒ½æœ‰ä¸€ä¸ª*key path*ã€‚ key pathæ˜¯list of *keys*ï¼Œè¯¥åˆ—è¡¨çš„é•¿åº¦æ˜¯leafçš„æ·±åº¦ã€‚æ¯ä¸ªé”®éƒ½æ˜¯ä¸€ä¸ªæ•£åˆ—å¯¹è±¡ï¼Œä»£è¡¨å¯¹åº” pytree èŠ‚ç‚¹**ç±»å‹**çš„ç´¢å¼•ã€‚é”®çš„ç±»å‹å–å†³äº pytree èŠ‚ç‚¹ç±»å‹ï¼›ä¾‹å¦‚ï¼Œdict çš„é”®ç±»å‹ä¸ tuples çš„é”®ç±»å‹ä¸åŒã€‚

å’Œé”®è·¯å¾„ç›¸å…³çš„APIï¼š

- `jax.tree_util.tree_flatten_with_path`: å’Œ`jax.tree_util.tree_flatten`ç±»ä¼¼ï¼Œé™¤äº†å€¼è¿˜è¿”å›key path

- `jax.tree_util.tree_map_with_path`: å’Œ`jax.tree_util.tree_map`ç±»ä¼¼,

- `jax.tree_util.keystr`ï¼Œè¿”å›æ˜“è¯»çš„å­—ç¬¦ä¸²å½¢å¼çš„key path

ç¤ºä¾‹ï¼š


```python
import collections
ATuple = collections.namedtuple("ATuple", ('name'))

tree = [1, {'k1': 2, 'k2': (3, 4)}, ATuple('foo')]
flattened, _ = jax.tree_util.tree_flatten_with_path(tree)
for key_path, value in flattened:
    print(f'Value of tree{jax.tree_util.keystr(key_path)}: {value}')
```

```
Value of tree[0]: 1
Value of tree[1]['k1']: 2
Value of tree[1]['k2'][0]: 3
Value of tree[1]['k2'][1]: 4
Value of tree[2].name: foo
```

ä¸ºäº†è¡¨ç¤ºkey pathï¼ŒJAX ä¸ºå†…ç½®çš„ pytree èŠ‚ç‚¹ç±»å‹æä¾›äº†å‡ ç§é»˜è®¤é”®ç±»å‹ï¼Œå³

- `SequenceKey(idx: int)`: for lists and tuples.
- `DictKey(key: Hashable)`: for dictionaries.
- `GetAttrKey(name: str)`: for `namedtuple`s and preferably custom pytree nodes (more in the next section)

ç”¨`repr(key_path)`å¯ä»¥çœ‹åˆ°è¿™äº›ç±»å‹

```python
for key_path, _ in flattened:
    print(f'Key path of tree{jax.tree_util.keystr(key_path)}: {repr(key_path)}')
```

```
Key path of tree[0]: (SequenceKey(idx=0),)
Key path of tree[1]['k1']: (SequenceKey(idx=1), DictKey(key='k1'))
Key path of tree[1]['k2'][0]: (SequenceKey(idx=1), DictKey(key='k2'), SequenceKey(idx=0))
Key path of tree[1]['k2'][1]: (SequenceKey(idx=1), DictKey(key='k2'), SequenceKey(idx=1))
Key path of tree[2].name: (SequenceKey(idx=2), GetAttrKey(name='name'))
```
<br>

ä¹Ÿå¯ä»¥ä¸ºè‡ªå·±çš„è‡ªå®šä¹‰èŠ‚ç‚¹å®šä¹‰è‡ªå·±çš„é”®ç±»å‹ã€‚åªè¦å®ƒä»¬çš„ `__str__()`æ–¹æ³•ä¹Ÿä½¿ç”¨äº†ä¾¿äºé˜…è¯»çš„è¡¨è¾¾å¼ï¼Œå®ƒä»¬å°±èƒ½ä¸ `jax.tree_util.keystr` ä¸€èµ·å·¥ä½œï¼Œå…·ä½“å†…å®¹è§ä¸‹èŠ‚

## Custom pytree nodes

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªè€ƒè™‘äº†åˆ—è¡¨ã€å…ƒç»„å’Œå­—å…¸çš„ pytreesï¼›å…¶ä»–ä¸€åˆ‡éƒ½è¢«è§†ä¸ºå¶å­ã€‚å› æ­¤ï¼Œå¦‚æœä½ å®šä¹‰äº†è‡ªå·±çš„å®¹å™¨ç±»ï¼Œé‚£ä¹ˆå³ä½¿å®ƒé‡Œé¢æœ‰æ ‘ï¼Œä¹Ÿä¼šè¢«è§†ä¸ºå¶å­ï¼š

```python
class MyContainer:
  """A named container."""

  def __init__(self, name: str, a: int, b: int, c: int):
    self.name = name
    self.a = a
    self.b = b
    self.c = c
    
jax.tree_util.tree_leaves([
    MyContainer('Alice', 1, 2, 3),
    MyContainer('Bob', 4, 5, 6)
])
```

```py
try:
    jax.tree_map(lambda x: x + 1, [
        MyContainer('Alice', 1, 2, 3),
        MyContainer('Bob', 4, 5, 6)
    ])
except TypeError as e:
    print(f'TypeError: {e}')
```

```
TypeError: unsupported operand type(s) for +: 'MyContainer' and 'int'
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå°è¯•ç”¨`jax.tree_map`å¯¹è‡ªå®šä¹‰çš„å®¹å™¨ä¸­çš„listçš„åšæ“ä½œï¼Œä½†æ˜¯pytreeå¹¶ä¸è®¤è¯†å®¹å™¨å†…çš„listï¼Œæ‰€ä»¥ä¼šæŠ¥é”™ã€‚æ‰€ä»¥éœ€è¦æŠŠè‡ªå®šä¹‰çš„å®¹å™¨åœ¨jaxä¸­æ³¨å†Œï¼Œå®ç°`flatten`å’Œ`unflatten`ä¸¤ä¸ªæ–¹æ³•

```python
from typing import Iterable

def flatten_MyContainer(container) -> tuple[Iterable[int], str]:
  """Returns an iterable over container contents, and aux data."""
  flat_contents = [container.a, container.b, container.c]

  # we don't want the name to appear as a child, so it is auxiliary data.
  # auxiliary data is usually a description of the structure of a node,
  # e.g., the keys of a dict -- anything that isn't a node's children.
  aux_data = container.name
  return flat_contents, aux_data

def unflatten_MyContainer(
    aux_data: str, flat_contents: Iterable[int]) -> MyContainer:
  """Converts aux data and the flat contents into a MyContainer."""
  return MyContainer(aux_data, *flat_contents)

# register
jax.tree_util.register_pytree_node(
    MyContainer, flatten_MyContainer, unflatten_MyContainer)

jax.tree_util.tree_leaves([
    MyContainer('Alice', 1, 2, 3),
    MyContainer('Bob', 4, 5, 6)
])
```

```
[1, 2, 3, 4, 5, 6]
```

> [!abstract] åœ¨Jaxä¸­æ³¨å†Œå®¹å™¨
>
> ```python
> jax.tree_util.register_pytree_node(
>     MyContainer, flatten_MyContainer, unflatten_MyContainer)
> ```
>
> ```python
> def flatten_MyContainer(container) -> tuple[Iterable[int], str]
> ```
>
> ```python
> def unflatten_MyContainer(
>     aux_data: str, flat_contents: Iterable[int]) -> MyContainer:
> ```

### Register container with its keys

å¦‚æœè¦ä½¿å¾—è‡ªå®šä¹‰çš„å®¹å™¨æœ‰key path:

```python
class MyKeyPathContainer(MyContainer):
  pass

def flatten_with_keys_MyKeyPathContainer(container) -> tuple[Iterable[int], str]:
  """Returns an iterable over container contents, and aux data."""

  # GetAttrKey is a common way to express an attribute key. Users are free
  # to pick any other expression that fits their use cases the best.
  flat_contents = [(jax.tree_util.GetAttrKey('a'), container.a),
                   (jax.tree_util.GetAttrKey('b'), container.b),
                   (jax.tree_util.GetAttrKey('c'), container.c)]

  # we don't want the name to appear as a child, so it is auxiliary data.
  # auxiliary data is usually a description of the structure of a node,
  # e.g., the keys of a dict -- anything that isn't a node's children.
  aux_data = container.name
  return flat_contents, aux_data

def unflatten_MyKeyPathContainer(
    aux_data: str, flat_contents: Iterable[int]) -> MyKeyPathContainer:
  """Converts aux data and the flat contents into a MyContainer."""
  return MyKeyPathContainer(aux_data, *flat_contents)

jax.tree_util.register_pytree_with_keys(
    MyKeyPathContainer, flatten_with_keys_MyKeyPathContainer, unflatten_MyKeyPathContainer)

jax.tree_util.tree_leaves([
    MyKeyPathContainer('Alice', 1, 2, 3),
    MyKeyPathContainer('Bob', 4, 5, 6)
])
```

```
[1, 2, 3, 4, 5, 6]
```

å¯¹æ²¡æœ‰å£°æ˜keyçš„è‡ªå®šä¹‰å®¹å™¨ä½¿ç”¨`*_with_path`æ–¹æ³•ï¼Œä¼šè¿”å›ä¸€ç§`flat index`

```python
flattened, _ = jax.tree_util.tree_flatten_with_path(MyContainer('Alice', 1, 2, 3))
for key_path, value in flattened:
    print(f'MyContainer container{jax.tree_util.keystr(key_path)}: {value}')

flattened, _ = jax.tree_util.tree_flatten_with_path(MyKeyPathContainer('Alice', 1, 2, 3))
for key_path, value in flattened:
    print(f'MyKeyPathContainer container{jax.tree_util.keystr(key_path)}: {value}')
```

```
MyContainer container[<flat index 0>]: 1
MyContainer container[<flat index 1>]: 2
MyContainer container[<flat index 2>]: 3
MyKeyPathContainer container.a: 1
MyKeyPathContainer container.b: 2
MyKeyPathContainer container.c: 3
```

## Common pytree gotchas and patterns

### Gotchas

#### Mistaking nodes for leaves

æ“ä½œå¯¹è±¡æé”™äº†

```python
a_tree = [jnp.zeros((2, 3)), jnp.zeros((3, 4))]

# Try to make another tree with ones instead of zeros
shapes = jax.tree_map(lambda x: x.shape, a_tree)
jax.tree_map(jnp.ones, shapes)
```

```
[(Array([1., 1.], dtype=float32), Array([1., 1., 1.], dtype=float32)),
 (Array([1., 1., 1.], dtype=float32), Array([1., 1., 1., 1.], dtype=float32))]
```

æƒ³æ¸…æ¥šï¼`tree_map`æ“ä½œçš„å®é™…ä¸Šæ˜¯å¯è¿­ä»£çš„å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯å½“å‰å®¹å™¨çš„**leaf**ï¼Œæ‰€ä»¥å¯¹`a_tree`

ä¼šå¾—åˆ°`[(2,3),(3,4)]`

> æ³¨æ„ï¼
>
> leafï¼æ‰€ä»¥æ˜¯2ï¼Œ3ï¼Œ3ï¼Œ4

æ‰€ä»¥`jnp.ones`ä¼šå¯¹2ï¼Œ3ï¼Œ3ï¼Œ4åˆ†å¼€æ“ä½œ

<br>

é‚£ä¹ˆæ€ä¹ˆå®ç°ä¸æ”¹å˜æ•°ç»„ç»“æ„ï¼Œç›´æ¥æŠŠ0æ”¹æˆ1å‘¢

- é‡å†™ä»£ç ï¼Œä¸å¯¹å¤šçº§çš„pytreeä½¿ç”¨`tree_map`
- â­ å°†å…ƒç»„è½¬åŒ–ä¸º`np.array`æˆ–è€…`jnp.array`ï¼Œä½¿å¾—æ•´ä¸ªåºåˆ—æˆä¸ºleaf

### Handling of None

`jax.tree_utils`å°†`None`è§†ä¸ºæ— å­èŠ‚ç‚¹çš„nodeï¼Œè€Œä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼š

```python
jax.tree_util.tree_leaves([None, None, None])
```

```
[]
```

### Patterns

#### Transposing trees â­

ä¾‹å¦‚ï¼ŒæŠŠ`a list of trees` å˜æˆ`a tree of lists`

```python
def tree_transpose(list_of_trees):
  """Convert a list of trees of identical structure into a single tree of lists."""
  return jax.tree_map(lambda *xs: list(xs), *list_of_trees)


# Convert a dataset from row-major to column-major:
episode_steps = [dict(t=1, obs=3), dict(t=2, obs=4)]
tree_transpose(episode_steps)
```

```
{'obs': [3, 4], 't': [1, 2]}
```

> ç†è§£ï¼
>
> æ€ä¹ˆç†è§£`jax.tree_map(lambda *xs: list(xs), *list_of_trees)`
>
> `*list_of_trees`ç›¸å½“äºè‹¥å¹²ä¸ªå‚æ•°çš„æ„æ€ï¼Œ*xsåŒ…å«äº†ä»è¿™äº›è‹¥å¹²å‚æ•°é‡Œå–å¾—çš„ç›¸åŒä½ç½®çš„leafï¼Œç»è¿‡æ˜ å°„å˜æˆä¸€ä¸ªlist
>
> åŸæœ¬çš„`[tree1, tree2, tree3...]`è¢«`*`è§£åŒ…ä¸ºå„ä¸ªå‚æ•°ï¼Œæ‰€ä»¥æ¯æ¬¡ä»ä¸åŒtreeä¸­å–å¾—å…ƒç´ ï¼Œç»è¿‡æ˜ å°„å¾—åˆ°ä¸€ä¸ªlist

<br>

å¯¹äºæ›´å¤æ‚çš„è½¬æ¢ï¼ŒJaxæä¾›äº†`jax.tree_trannpose`ï¼Œéœ€è¦æŒ‡æ˜å‡½æ•°è¾“å…¥çš„å†…å±‚å’Œå¤–å±‚çš„ç»“æ„

```python
jax.tree_transpose(
  outer_treedef = jax.tree_structure([0 for e in episode_steps]),
  inner_treedef = jax.tree_structure(episode_steps[0]),
  pytree_to_transpose = episode_steps
)
```

```
{'obs': [3, 4], 't': [1, 2]}
```

## More information

see [Pytrees](https://jax.readthedocs.io/en/latest/pytrees.html)

[^1]: https://jax.readthedocs.io/en/latest/pytrees.html
[^2]: https://www.programiz.com/python-programming/methods/built-in/repr
[^3]:https://www.runoob.com/python/python-func-map.html
[^4]: https://www.runoob.com/python/python-func-zip.html